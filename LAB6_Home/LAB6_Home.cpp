// LAB6_Home.cpp: определяет точку входа для консольного приложения.
//

#include "stdafx.h"
#include <iostream> 

//ЛАБОРАТОРНАЯ РАБОТА № 6

 // Задачи: 
// 1) сложение матриц
// 2) сложение векторов 
// 3) умножение матриц 
// 4) умножение матрицы на вектор  
// 5) скалярное умножение векторов 
// 6) векторное умножение векторов 
// 7) вывод матрицы с помощью функций 
// реализовать программно 

int MATR_1[3][3] = { { 1, 2, 3 },
{ 4, 5, 6 },  // объявляем матрицу №1
{ 7, 8, 9 } };

int MATR_2[3][3] = { { 1, 2, 3 },
{ 4, 5, 6 },  // объявляем матрицу №2
{ 7, 8, 9 } };


int MATR_RESULT[3][3] = { { 0, 0, 0 },
{ 0, 0, 0 },  //обявляем итоговую матрицу, в которой будет записан ответ
{ 0, 0, 0 } };

int VECTOR_1[1][3] = { 1, 2, 3 }; // объявляем вектор №1

int VECTOR_2[1][3] = { 1, 2, 3 }; // объявляем вектор №2


int VECTOR_RESULT[1][3] = { 0, 0, 0 }; // объявляем итоговый вектор

int SCALAR_X = 0; // объявление переменной, в которой будет записано скалярное произведение

void MATR_SUM(int(&MATR_RESULT)[3][3], int const MATR_1[3][3], int const MATR_2[3][3]) // функция, считающая суммы матриц
{
	for (int i = 0; i < 3; i++)
{
	for (int j = 0; j < 3; j++)
{
		MATR_RESULT[i][j] = MATR_1[i][j] + MATR_2[i][j]; // прописываем формулу сложения матриц
}

}
}
void VECTOR_SUM(int(&VECTOR_RESULT)[1][3], int const VECTOR_1[1][3], int const VECTOR_2[1][3]) // функция, считающая суммы векторов 
{
	for (int i = 0; i < 3; i++)
{
		VECTOR_RESULT[0][i] = 0;
		VECTOR_RESULT[0][i] = VECTOR_1[0][i] + VECTOR_2[0][i];  //прописываем формулу сложения векторов 
}
}

void MATR_X(int(&MATR_RESULT)[3][3], int const MATR_1[3][3], int const MATR_2[3][3]) // функци, служащая для умножения матриц 
{

    for (int i = 0; i < 3; i++)
{
	for (int j = 0; j < 3; j++)
{
		MATR_RESULT[i][j] = 0;
	for (int k = 0; k < 3; k++)
{
		MATR_RESULT[i][j] = MATR_RESULT[i][j] + MATR_1[i][k] * MATR_2[k][j]; // пропишем формулу для умножения матриц 
}
}
}
}

void MATR_X_VECTOR(int(&VECTOR_RESULT)[1][3], int const (*MATR_1)[3], int const VECTOR_1[1][3]) // функция для умножения матрицы на вектор 
{

	for (int i = 0; i < 3; i++)
{
	for (int j = 0; j < 3; j++) {
	VECTOR_RESULT[i][j] = 0;
}
}
	for (int i = 0; i < 3; i++)
{
	for (int j = 0; j < 3; j++)
{
		VECTOR_RESULT[0][i] = VECTOR_RESULT[0][i] + MATR_1[i][j] * VECTOR_1[0][j]; //пропишем формулу умножения матрицы на вектор 
}
}
}

void SCALAR_X_VECTOR(int(&SCALAR_X), int VECTOR_1[1][3], int VECTOR_2[1][3]) // функция для скалярного умножения векторов 
{
	for (int j = 0; j < 3; j++)
{
		SCALAR_X = SCALAR_X + VECTOR_1[0][j] * VECTOR_2[0][j]; //пропишем формулу для скалярного умножения векторов 
}
}

void VECTOR_X_VECTOR(int(&VECTOR_RESULT)[1][3], int const VECTOR_1[1][3], int const VECTOR_2[1][3]) // функция для векторного умноения векторов 
{
   for (int i = 0; i < 3; i++) {	// векторное умножение векторов 
	if (i == 0) {
	for (int j = 0; j < 3; j++) {
		MATR_RESULT[i][j] = 1;
}

}
	else 
{
	if (i == 1)
{
  for (int j = 0; j < 3; j++) 
 {
	  MATR_RESULT[i][j] = VECTOR_1[0][j];
}
}
	else 
{
	for (int j = 0; j < 3; j++)
{
		MATR_RESULT[i][j] = VECTOR_2[0][j];
}
}
}
}

	for (int i = 0; i < 3; i++) {
		VECTOR_RESULT[0][i] = 0;
}
	for (int i = 2; i > -1; i--)
{
	(i == 0) ?
	(VECTOR_RESULT[0][i] = MATR_RESULT[1][(i + 1) / 3] * MATR_RESULT[2][i + 1] - MATR_RESULT[1][i + 1] * MATR_RESULT[2][(i + 1) / 3])
			:
	(VECTOR_RESULT[0][i] = MATR_RESULT[1][(i + 1) / 3] * MATR_RESULT[2][2] - MATR_RESULT[1][2] * MATR_RESULT[2][(i + 1) / 3]);
}

}


void vivodMATR(int MATR_RESULT[3][3]) // функция для вывода итоговой матрицы 
{
	for (int i = 0; i < 3; i++)
{
	for (int j = 0; j < 3; j++)
{
	std::cout << MATR_RESULT[i][j] << "\t"; // вывод итоговой матрицы 
}
	std::cout << std::endl;
}
	std::cout << std::endl;
}


void vivodVECTOR(int VECTOR_RESULT[1][3]) // функция для вывода итогового вектора 
{
	std::cout << std::endl;
	for (int i = 0; i < 3; i++)
{
	std::cout << VECTOR_RESULT[0][i] << '\t'; // вывод итогового вектора 
}
	std::cout << std::endl;
	std::cout << std::endl;
}
int main()
{
	MATR_SUM(MATR_RESULT, MATR_1, MATR_2); // вызов функции для суммы матриц 
	vivodMATR(MATR_RESULT); // вызов функции для вывода итоговой 

	VECTOR_SUM(VECTOR_RESULT, VECTOR_1,VECTOR_2);  // вызов функции для суммы векторов 
	vivodVECTOR( VECTOR_RESULT); // вызов функции для вывода итогового вектора  


	MATR_X(MATR_RESULT, MATR_1,MATR_2); // вызов функции для произведения матриц 
	vivodMATR(MATR_RESULT); // вызов функции для вывода итогового матрицы 


	MATR_X_VECTOR(VECTOR_RESULT, MATR_1, VECTOR_1); // вызов функции для произведения матрицы на вектор 
	vivodVECTOR(VECTOR_RESULT); // вызов функции для вывода итогового вектора 


	SCALAR_X_VECTOR(SCALAR_X, VECTOR_1, VECTOR_2); // вызов функции для скалярного произведения векторов 
	std::cout << SCALAR_X << std::endl; // вызов функции для вывода скалярного произведения 



	VECTOR_X_VECTOR(VECTOR_RESULT, VECTOR_1, VECTOR_2); // вызов функции для векторного произведения векторов 
	vivodVECTOR(VECTOR_RESULT); // вызов функции для вывода результирующего вектора 

	getchar();
    return 0;
}

// GIT - это система управления версиями файлов.Физически представляет из себя консольное приложение со своей системой команд.Позволяет: 
// 1. создавать снимки текущего состояния файлов (версии)
// 2. откатываться к предыдущим версиям, сливать версии вместе 
// 3. позволяет работать с удаленным хранилищем (репозиторием) 
// 4. является удобным средством командной работы 
// GIT в первую очередь нацелен на эффективную работу с не заархивинованными текстовыми файлами (не сжатыми) 
// в этом случае GIT фиксирует изменения, определяет различия текущей и предыдущей версий вплоть до отдельных строк или символов 
// и найденные изменения, различия записываются в новом снимке 
// это способствует экономии дискового пространства при хранении множества версий 

/*
ОСНОВЫ РАБОТЫ С GIT

1) Начало работы - инициализация репозитория:

CD <папка *.sln решения>
git init

cd: - change directory (на уровень выше)

главная ветка проекта называется master

появляется скрытая папка .git, где и будет хранться история изменений и настройки

2) по умолчанию git будет фиксировать историю файлов кода с известными расширениями:
txt, cpp, h, hpp, hxx, c
py, xml, html
однако в репозиторий также требуется включать и файлы проектов и решений
которые git сам не учитывает
для этого нужно воспользоваться командой

git add <имя_файла>

достаточо добавить учёт файла в репозитории 1 раз
категорически не следует добавлять исполняемые файлы,
временные и автоматически генерируемые файлы:
*.exe, *.lib, *.dll, *.pch, *.ipch, *.db, *.pdb и др.
не слеудет добавлять целиком папки /x86, /x64, /release, /debug.

3) зафиксировать версию (снимок) группы файлов

git commit -m"Комментарий к версии"

Ввод комментария строго обязателен.

4) для синхронизации с удалённым репозиторием
нужно
-закоммитить изменения в локальном
-прописать адрес удалённого

git remote add <краткий_псевдоним> <ссылка>

5) в любой момент можно посмотреть статус репозитория через

git status

6) получить справку по любой команде

git <имя_команды> --help

7) после переименования файла нужно:

1. git add <новое имя>
2. !!! в некоторых случаях, когда git status выдаёт missing: <старое_имя_файла>
git delete -cached <старое_имя_файла>

8) для любителей графических решений можно использовть TortoiseGit -
расширение проводника Windoes, добавляющее контекстные команды для управления репозиториями


9) СОЗДАЁТСЯ КОПИЯ УДАЛЁННОГО РЕПОЗИТОРИЯ КОМАНДОЙ  GIT CLONE И http:// ...
1) в начале пары -  GIT CLONE
2) в ходе лабораторной работы с кодом
3) после работы фиксация изменений git commit и заливка на удаленный git push
*/

